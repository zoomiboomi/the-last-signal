<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Last Signal - 3D Local</title>
<style>
body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#0a0a0a; }
#scanlines {
    position:fixed; top:0; left:0; width:100%; height:100%;
    pointer-events:none;
    background: repeating-linear-gradient(rgba(0,255,0,0.03) 0 1px, transparent 1px 2px);
    z-index:4;
}
canvas{display:block;}
</style>
</head>
<body>
<div id="scanlines"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script>
// ===== Scene & Camera =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,1.6,5);

// ===== Renderer =====
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== Lighting =====
scene.add(new THREE.AmbientLight(0x00ff00, 0.3));
const pointLight = new THREE.PointLight(0x00ff00, 0.7, 50);
pointLight.position.set(0,5,0);
scene.add(pointLight);

// ===== Floor & Walls =====
const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x0a0a0a}));
floor.rotation.x = -Math.PI/2; scene.add(floor);

const wallMaterial = new THREE.MeshStandardMaterial({color:0x001100});
scene.add(new THREE.Mesh(new THREE.BoxGeometry(50,10,1), wallMaterial).position.set(0,5,-25));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(50,10,1), wallMaterial).position.set(0,5,25));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMaterial).position.set(-25,5,0));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMaterial).position.set(25,5,0));

// ===== Ghost =====
const ghost = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000}));
ghost.position.set(5,0.5,5); scene.add(ghost);

// ===== Clue =====
const clue = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0x00ff80}));
clue.position.set(-5,0.25,-5); scene.add(clue);
let clueCollected = false;

// ===== Movement =====
const move = {forward:false, back:false, left:false, right:false};
document.addEventListener('keydown', e=>{
    if(e.key==='w') move.forward=true;
    if(e.key==='s') move.back=true;
    if(e.key==='a') move.left=true;
    if(e.key==='d') move.right=true;
});
document.addEventListener('keyup', e=>{
    if(e.key==='w') move.forward=false;
    if(e.key==='s') move.back=false;
    if(e.key==='a') move.left=false;
    if(e.key==='d') move.right=false;
});

// ===== Animate =====
function animate(){
    requestAnimationFrame(animate);

    // Player simple keyboard movement (no pointer lock)
    const velocity = 0.1;
    if(move.forward) camera.position.z -= velocity;
    if(move.back) camera.position.z += velocity;
    if(move.left) camera.position.x -= velocity;
    if(move.right) camera.position.x += velocity;

    // Ghost simple random movement
    ghost.position.x += (Math.random()-0.5)*0.05;
    ghost.position.z += (Math.random()-0.5)*0.05;

    // Collision detection
    if(ghost.position.distanceTo(camera.position) < 1){
        alert("Caught by ghost!");
        window.location.reload();
    }
    if(!clueCollected && clue.position.distanceTo(camera.position) < 1){
        clueCollected=true;
        scene.remove(clue);
        alert("Clue collected! Case solved!");
        window.location.reload();
    }

    renderer.render(scene,camera);
}
animate();

// ===== Resize =====
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
