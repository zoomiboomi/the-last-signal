<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Last Signal - 3D Safe</title>
<style>
body, html { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#0a0a0a; font-family: monospace; color:#00ff00; }
#scanlines { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; background: repeating-linear-gradient(rgba(0,255,0,0.03) 0 1px, transparent 1px 2px); z-index:4; }
#message { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:24px; text-align:center; display:none; }
canvas{display:block;}
</style>
</head>
<body>
<div id="scanlines"></div>
<div id="message"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script>
// ===== Scene =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);

// ===== Camera =====
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,1.6,5);

// ===== Renderer =====
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== Lighting =====
scene.add(new THREE.AmbientLight(0x00ff00,0.3));
const pointLight = new THREE.PointLight(0x00ff00,0.7,50);
pointLight.position.set(0,5,0);
scene.add(pointLight);

// ===== Floor & Walls =====
const floor = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x0a0a0a}));
floor.rotation.x = -Math.PI/2; scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({color:0x001100});
scene.add(new THREE.Mesh(new THREE.BoxGeometry(50,10,1), wallMat).position.set(0,5,-25));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(50,10,1), wallMat).position.set(0,5,25));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMat).position.set(-25,5,0));
scene.add(new THREE.Mesh(new THREE.BoxGeometry(1,10,50), wallMat).position.set(25,5,0));

// ===== Ghost =====
const ghost = new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000}));
ghost.position.set(5,0.5,5); scene.add(ghost);

// ===== Clue =====
const clue = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0x00ff80}));
clue.position.set(-5,0.25,-5); scene.add(clue);
let clueCollected = false;

// ===== DOM message =====
const messageDiv = document.getElementById('message');

// ===== Movement =====
const move = {forward:false, back:false, left:false, right:false};
document.addEventListener('keydown', e=>{
    if(e.key==='w') move.forward=true;
    if(e.key==='s') move.back=true;
    if(e.key==='a') move.left=true;
    if(e.key==='d') move.right=true;
});
document.addEventListener('keyup', e=>{
    if(e.key==='w') move.forward=false;
    if(e.key==='s') move.back=false;
    if(e.key==='a') move.left=false;
    if(e.key==='d') move.right=false;
});

// ===== Animate =====
const velocity = 0.1;
function animate(){
    requestAnimationFrame(animate);

    // Move player
    if(move.forward) camera.position.z -= velocity;
    if(move.back) camera.position.z += velocity;
    if(move.left) camera.position.x -= velocity;
    if(move.right) camera.position.x += velocity;

    // Ghost random movement
    ghost.position.x += (Math.random()-0.5)*0.05;
    ghost.position.z += (Math.random()-0.5)*0.05;

    // Collision
    if(ghost.position.distanceTo(camera.position) < 1 && messageDiv.style.display === 'none'){
        messageDiv.innerText = "Caught by ghost!";
        messageDiv.style.display = 'block';
    }
    if(!clueCollected && clue.position.distanceTo(camera.position) < 1){
        clueCollected = true;
        scene.remove(clue);
        messageDiv.innerText = "Clue collected! Case solved!";
        messageDiv.style.display = 'block';
    }

    renderer.render(scene,camera);
}
animate();

// ===== Resize =====
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
